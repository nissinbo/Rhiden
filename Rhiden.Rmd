---
title: "R秘伝の書"
author: "nissinbo"
date: "`r Sys.time()`"
output:
    html_document:
     includes:
     pandoc_args:
     - --from
     - markdown+autolink_bare_uris+tex_math_single_backslash-implicit_figures
     toc: true
     toc_float: true
     toc_depth: 3
     number_section: true
     theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```
# はじめに

- **目次またはCtrl+Fで知りたいことを探してみよう。**
- これ自体はR Markdownで書かれている。

- - -

# ディレクトリ

## 作業ディレクトリ確認

```{r getwd}
getwd()
```

## 作業ディレクトリ設定  

```{r setwd}
setwd("C:/Users")  
```

一時的に変えたいならCtrl+Shift+H。  
相対パスでの設定もできる。
<!-- 相対パスの実例を入れる ("../data/data.R")みたいなやつ -->

### スクリプトファイルが存在するとこにsetwdしたい

```{r setwd_here}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

超おすすめ！  
フォルダ構造さえ保っていれば変更しなくてよくなる。  

- - -  

# 入力

## Excelから読込(csv)

### read.csv

Rのデフォルト関数read.csv()

```{r readcsv}
df <- read.csv("df.csv", stringsAsFactors = F)  
```

stringsAsFactors = Fは文字データをcharacterで読み込んでくれるので**絶対につける**。  
factorはミスの温床。  

### fread

```{r fread}
library(data.table)
df <- fread("df.csv", stringsAsFactors = FALSE, sep = ",", data.table = FALSE)
```

爆速なfread()。これのおかげでSASでの切り出しは最小限で済む。  
デフォルトではdata.tableという謎の形で読み込むので、データフレームにするためdata.table=FALSEをつける。  

### 事前に型や名前を指定して読み込み

read.csv()でもfread()でも使える。  
Rは読み込み時にいい感じで型を決めてくれるが、これを使ってやるのが一番安全。  
特に患者IDは桁数が大きいことがあり、characterにしてから処理すべき。  

```{r}
data <- read.csv('test.csv', colClasses = c("character", "character", rep("numeric",3), "character"), col.names = c("c1", "c2", "c3", "c4", "c5", "c6"))
```


## Excelから読込(xlsx)

{openxlsx}パッケージが手軽で便利。

```{r openxlsx}
library(openxlsx)
df <- read.xlsx("df.xlsx")
```

read.xlsx()ではstringsAsFactors等のオプションが使えないので、読み込んだ後にしっかり確認すること。

## SASデータから読込(sas7bdat)

{haven}という、SAS形式を直接読み取るパッケージが[ある](https://y-mattu.hatenablog.com/entry/2016/12/09/083000)。しかし一度csvにしてからインポートするのをおすすめします。  

# 出力・保存

## RDataで出力

```{r save}
save(df, file = "df.RData")  
```

「file=」と、拡張子RDataを書き忘れないように  
RDataで保存すれば次回以降読み込みがぐっと速くなる。

```{r save2}
save(df1, df2, df3, file = "df.RData")  
```

上記のように複数のオブジェクトを一つのRDataに保存することも可能。

## csvで出力

```{r writecsv}
write.csv(df, "df.csv", row.names = F)  
```

row.names = Fはマスト。デフォルトでは、行番号が1列目に追加されてしまう。  

## xlsxで出力

```{r writexlsx}
library(openxlsx)
write.xlsx(df, "df.xlsx")  
```

Excel使いさんにデータを渡すまたはデータをまとめるときは、xlsxにしてあげると優しい。  
openxlsxパッケージを使う。こちらはデフォルトでrow.names=F。  

## 結果の出力

コンソールに出力される結果を保存したいとき

### sinkを使う方法

```{r sink}
sink("/result.txt",append = FALSE)
#なんらかの出力を伴う作業
sink()
```

sink("ファイルパス")で出力ファイル先を指定。sink()で設定が取り消される。  
append=FALSEだと上書きされるので、結果を追記したい場合はTRUEにする。  

### catを使う方法

capture.output()はそのコマンドの結果を文字列として受け取るので、それをcatで保存する。

```{r cat}
out <- capture.output(t.test(1:10))
cat(out, "capout.txt", sep = "\n")
```

- - -

# データ編集関連

<!-- 全体として、結果の実例がほしい -->
<!-- このコードでこうなる！みたいな -->
基本的に{tidyverse}にある{dplyr}パッケージの関数を使うのが効率がよいとされている。  
ただ、あえて古めかしい書き方も残しておく。何故なら、泥臭い試行錯誤をするときに使えるし、パッケージドキュメント等はまだbase記法が多数派だから。  
最初に言っておくと、「列の削除・選択・入替」は{dplyr}のselect関数というもので完結できる。[参考文献](https://kazutan.github.io/kazutanR/hands_on_170730/select.html)  

## 列の追加

### レトロ

$(ドルマーク)は「の」という意味。

```{r $}
df$hoge <- df$huga + df$piyo
```

この例はdfのhugaとpiyoの合計のhogeという列を作成。  
  
add_columnを使うと、指定の位置に列を追加できる。  

### モダン

またdplyrパッケージを使うと  

```{r mutate1}
library(dplyr)
df <- mutate(df,hoge = huga + piyo)
```
  
mutateは違う名前のデータフレームを作成し、そこに代入することもできる。  

```{r mutate2}
library(dplyr)
df2 <- mutate(df,hoge = huga + piyo)
```  

### 3つ以上の列から最大や最小を求める

A列、B列、C列の中の最大値を求めたいというとき、rowwiseを使う。

```{r}
df <- df %>% 
  rowwise() %>% 
  mutate(abc_max = max(A,B,C))
```

rowwiseなくてもいけそうな雰囲気があるけど、maxやminはデフォルトでは列方向にしか働かない。

## 列の編集

列名は変えず中身を編集したい場合(数値から文字列にしたい等)  
「列の追加」のとこの動きを、新しい列名を既存の列名に置き換えればできる。例えば

```{r mutate_same_col}
df <- mutate(df,hoge = as.character(hoge))
```

### mutate_at

又はmutate_atを使う。こっちの方が楽。

```{r}
df2 <- df %>% 
  mutate_at(vars(hoge),~as.character(.))
```

### mutate_all

df内の全ての列に操作を適用したい場合はmutate_all。

```{r}
new_df <- ori_df %>% 
  mutate_all(~as.character(.))
```

### mutate_if

条件に合った列だけに操作を適用したい場合はmutate_if。

```{r}
new_df <- ori_df %>% 
  mutate_if(is.factor, ~as.character(.))
# factorの列のみをcharacterに変換
```

## 列の削除

### レトロ

列番号を指定して削除する方法  

```{r remove1}
df2 <- df[,c(-3,5,6)]
```

上の例は3,5,6列目を削除
  
次は列名を指定して削除

```{r remove2}
df3 <- df[, colnames(df) != "piyo"]
```

上はpiyoを削除

### モダン

またdplyrパッケージを使うと  

```{r remove3}
library(dplyr)
df2 <- select(df,-3,-5,-6)
df3 <- select(df,-piyo)
```

これで上と同じ挙動を示す。  

## 列の選択

### モダン

列番号を指定して残す方法 selectを使う

```{r select}
library(dplyr)
df2 <- select(df,2,3,5)
```

2,3,5列を残す

```{r select2}
library(dplyr)
df2 <- select(df,hoge,piyo)
```

hoge、piyo列を残す。

### 列名が重複してる場合

列名が重複してるデータをもらうことがある。その時はselect等で列名を指定することができないため、

```{r}
df <- df[, unique(colnames(df)), with = FALSE]
```

を使って片方の列を消すか、

```{r}
tibble::repair_names()
```
を使うと列名の重複を解消してくれる。

## 列の入替

### レトロ

列番号を指定して入れ替える方法
```{r replace1}
df2 <- df[,c(2,3,4,1,5)]
```

dfの列番号を2,3,4,1,5にしたものをdf2に代入  
  
列名を指定して入れ替え

```{r replace2}
df2 <- df[,c("b","c","d","a","e")]
```

### モダン

dplyrを使うと、

```{r replace3}
df2 <- select(df,2,3,4,1,5)
df2 <- select(df,b,c,d,a,e)
```

## 列の名前変更

### レトロ

列名を全部変更したいときはcolnamesが便利

```{r colnames1}
colnames(df) <- c("hoge","piyo","hugahuga")
```

左から順番にhoge、piyo、hugahugaという列名にする。  
colnamesを使う時は指定する列の数があってないとダメ。  

### モダン

{magrittr}パッケージの関数を使うと、

```{r set_colnames}
df <- set_colnames(df,c("hoge","piyo","hugahuga"))
```

これも指定する列の数があってないとダメ。  
こっちが便利な理由は、パイプ記法にマッチしている点。 
  
一部を変更するときはdplyrのrenameを使う。

```{r rename}
library(dplyr)
df2 <- rename(df,piyopiyo = hoge)
```

hogeという列をpiyopiyoという名前に変更する。  
  
## 列名取得

データフレームの列名を取得したいときはcolnamesを使う。

```{r colnames2}
colnames(df)
```

こうするとdfの列名が一覧で表示される。  

## 並べ替え

### レトロ

orderを使う場合

```{r order}
df2 <- df[order(df$ID),]
```

### モダン

dplyrのarrangeを使う場合

```{r arrange}
library(dplyr)
df2 <- arrange(df,ID)
```

## 条件によるフィルタ

### レトロ

subsetを使う場合

```{r subset}
df2 <- subset(df,age >= 50)
```

等号、不等号などの表現は以下の通り[参考文献](http://cse.naro.affrc.go.jp/takezawa/r-tips/r/28.html)  
==、<=、<、>=、>、!=(ノットイコール)  
  
### モダン

dplyrのfilterを使う場合

```{r filter }
library(distinct)
df2 <- filter(df,name == "Suzuki")
```

文字のときは""で囲む  

### その人のx番目の行を取得

#### row_number()を使う

```{r}
df2 <- df %>% 
  group_by(id) %>% 
  filter(row_number() == 2) %>%  # ここの数字を変えてx番目の行を取得
  ungroup()
```

#### top_n()を使う

```{r}
df2 <- df %>% 
  group_by(ID) %>% 
  top_n(2, date) %>%   # ここの数字を変えてx番目の行を取得
  ungroup()
```

## 重複削除

### レトロ

duplicatedを使うと重複したものが抽出される。!duplicatedは重複した行の一番上を抽出する。  

```{r duplicated}
df2 <- df[!duplicated(df$ID),]
```

上の例はdfのIDという列で重複をチェックし、重複削除。  
  
### モダン

#### distinct

```{r distinct}
library(dplyr)
df2 <- distinct(df,ID,.keep_all = TRUE)
```

.keep_all=Fとすると、キーにした列のみが出力される。  

#### first

```{r first}
df2 <- df %>% 
  group_by(id) %>% 
  first() %>% 
  ungroup()
```


## データを縦に結合

### レトロ

rbindを使う。データがビッグだと動きがバカ重い。  

```{r rbind}
new_data <- rbind(data1,data2,data3)
```

全てのデータフレームの列名が一致していないとダメ。  
  
### モダン

dplyrのbind_rows又はrbind_allを使う場合  
こっちの方が動きが軽いらしい。  

```{r bind_rows}
library(distinct)
new_data <- bind_rows(data1,data2,data3)
#または
new_data <- rbind_all(data1,data2,data3)
```

この2つはほとんど同じ動きだが、列名が一致してないときとか違う挙動を示す?誰か追記してください。    
  
## データを横に結合

### レトロ

列を結合したいときはcbindを使う。

```{r cbind}
new_data <- cbind(data1,data2)
```

行数が一致していないとダメ。  
  
### モダン

dplyrのbind_colsを使う場合

```{r bind_cols}
new_data <- bind_cols(data1,data2)
```

行数が一致していないとダメ。  
※多分求めているのは↓の項目ではないですか？一応目を通してください。  

## マッチしたデータを横に結合

例えばIDが共通の人のデータをIDをキーにして結合するなど。  
ExcelでいうVLOOKUP関数。JOINファミリーを使う。  

```{r left_join}
new_data <- left_join(data1,data2,"ID")
```
  
```{r inner_join}
new_data <- inner_join(data1,data2,"ID")
```

left_join、inner_joinの違いは[参考文献](https://qiita.com/matsuou1/items/b1bd9778610e3a586e71)を参照のこと。  
  
### 2つのデータで同じ名前の列があるとき

そのままだと接尾に「.x」と「.y」がつくが、suffixを使うと自分で指定できる。

```{r}
inner_join(x, y, "id", suffix = c("_original", "_new"))
```

## リストにある人の情報を取得

### レトロ

%in%を使う。例えばdata1のうちでdata2に存在する人のデータを抽出する。    

```{r %in%}
new_data <- data1[,data1$ID %in% data2$ID]
```

### モダン

実はこれもjoinファミリーでできる。(ver0.3追記)  

```{r semi_join}
new_data <- semi_join(data1,data2,"ID")
```

## リストにない人の情報を取得

### レトロ

%in%を使う。例えばdata1のうちでdata2に存在しない人のデータを抽出する。    

```{r anti_%in%}
new_data <- data1[,!data1$ID %in% data2$ID]
```

### モダン

実はこれもjoinファミリーでできる。(ver0.7追記)  

```{r anti_join}
new_data <- anti_join(data1,data2,"ID")
```  

## 1行ずらす(未編集)

- lag()
- lead()
  
- - -   

# 文字列

## 文字列置換

### if_else

一例としてwomenをfemaleに、menをmaleに変える  
if_elseを使う場合  
if_else(条件,true="",false="",missing="")と書く。true等は省略可

```{r if_else1}
df$sex <- if_else(df$sex == "women","female","male")
```
  
### gsub

```{r gsub }
df$sex <- gsub("women","female",df$sex)
df$sex <- gsub("men","male",df$sex)
```

[参考文献](https://stats.biopapyrus.jp/r/basic/string.html)
  
### levels

先にlevels()でR上の順序を見ておくといいかも

```{r levels}
levels(df$sex)
levels(df$sex) <- c("female","male")
```

### case_when
  
変えたいものが3つ以上あるときは、case_whenを使うと便利。 
様々な表現を年齢で統一したい…
上述のmutate（列の追加）と組み合わせればできます。

```{r case_when}
df <- mutate(df,newage = case_when(age=="高齢者" ~ "70歳代",
                       age=="成人" ~ "30歳代",
                       age=="乳幼児" ~ "10歳未満",
                       age=="小児" ~ "10歳未満",
                       age=="青少年" ~ "10歳代",
                       TRUE ~age))
```

直訳すると…  
newageという新しい列にageから置き換えた表現を入れます。  
ageでの「高齢者」はnewageでは【70歳代】、「成人」は【30歳代】、「乳幼児」は【10歳未満】、「青少年」は【10歳代】に変換します。  
ただし、どれにも当てはまらない場合はageに書かれているものをそのままnewageに書きます。  
ということになります。  
  
注意点:「TRUE\~〇〇」はその列のデータ型と同じものを書かないとエラーが出ます。

### str_replace_all(未編集)

stringr::str_replace_allを使うといい感じ。

- [参考](https://qiita.com/kazutan/items/0b690961d4516e48f6c0)

## 文字列結合

pasteを使う。sepで区切り文字を指定する。  

```{r paste}
df$new_var <- paste(df$ID,df$sex,sep = ",")
```

sepを指定しないと半角スペースになる。  
  
paste0だと区切り文字なし

```{r paste0}
df$new_var <- paste0(df$ID,df$sex)
```
  
## 文字列切り出し

substrを使う。[参考文献](https://stats.biopapyrus.jp/r/basic/string.html)  

```{r substr}
dna <- c("AAGCT", "TTAAA", "CCTAT")
substr(dna, 2, 3)
```

第2引数は切出しの開始位置、第3引数は終了位置を指定  
  
## 正規表現
  
- - -

# 欠損値
簡単には[*ここ*](https://qiita.com/five-dots/items/361a42baf1e94edf5846)に書いてあるよ。  
  
## 把握

### 列ごとに欠損セル個数を表示

```{r sapply}
df2 <- sapply(df, function(x) sum(is.na(x)))
```

xには適当な文字何でもいい。  

### 欠損列を含む行を表示

```{r}
data[!complete.cases(data),]
```

### 特定の列の欠損個数を表示

```{r table}
table(is.na(df$hoge))
```

## 穴埋め

### 基本

dplyrのif_elseを使う。
下の例は「もし欠損なら代入し、欠損でなければそのまま」という動き  

```{r if_else2}
library(dplyr)
df$hoge <- if_else(is.na(df$hoge),"ああ",df$hoge)
```

デフォルトのifelse関数は**絶対に**使わないでね。[参考文献](https://notchained.hatenablog.com/entry/2016/11/23/112729)    
TRUEとFALSEでデータ型が一致してないとダメだから注意。  

別の方法としては、まず対象の列が欠損の人とそうでない人に分け、欠損の人の値を埋め、さらに結合させて元に戻すというものがある。

```{r another_way}
ok <- df[is.na(df$hoge) = FALSE,]#欠損無し
loss <- df[is.na(df$hoge),]#欠損あり
loss$hoge <- rep("ああ",nrow(loss))#欠損の人の値を埋める
df2 <- rbind(ok,loss)#結合させて元に戻す
```

### 欠損を0で埋める

```{r}
df[is.na(df)] <- 0
```

## 除外

欠損がある「行」を全て削除する。  
つまりComplete Cases。

```{r }
df2 <- na.omit(df)
```

## LOCF

{tidyr}のfill()を使う。

```{r fill}
df2 <- df1 %>% 
  fill(age, value1)
```

- - -

# 把握

## ディレクトリ内ファイル把握

現在のワーキングディレクトリにあるファイルを把握するにはdirを使う。  
```{r dir}
dir()
```
  
## 次元把握

データフレームの行数と列数を把握するにはdimを使う。

```{r dim}
dim(data)
```
  
## データの型把握

列の型(実数、文字列…)を把握するにはmodeやtypeofを使う。

```{r mode}
mode(data$hoge)
```
  
## クロス集計表

```{r count_spread1}
df %>%
  count(var1, var2) %>%
  spread(var1, n)
```

[この方法もある](https://stackoverflow.com/questions/37364249/tidyr-how-to-spread-into-count-of-occurrence)

## データフレーム概要

- {summarytools}パッケージのdescr()、dfSummary()
- summary
- glimpse
- n_distinct(id)  # 重複消して何人いるか把握
- skimr  # 最近流行ってるらしい

- - -

# オブジェクト管理

## 削除

### 個別に削除

```{r}
rm()
```

### DF全削除

```{r}
rm(list = ls(all = TRUE))
```

又はR Studioの右上のほうきボタンを押す。

- - -

# 日付

## 計算

日付関連はlubridateパッケージが便利  
基本的に「(年×12+月)-(年×12+月)」で2つの年月の差が何か月か求まるということを念頭に置く。  
また、日付の計算はたくさんやるので自分で関数を作るとよいと思う。  
  
## 日付変換

### for Windows

1899年12月30日を起算日とした5桁の形式を変換する。起算日は25569。  
よくわかってないので誰か書いて or 不要なら消して。

```{r }
x <- as.Date(x,origin = "1899-12-30")
```

## lubridateパッケージ

- ymd(0000-00-00)
- year,month関数

```{r }
ymd(2012-02-10)
ymd(20120210)
ymd(2012/2/10)
```

この3つどれでも適用があるらしいです。  
また、()の中が列を指定していても読み込んでくれます。  
以下はその例です。

```{r }
ymd(df$vector)
```

## 年、月の抽出

よくあるのは201004のように上4桁で年、下2桁で月を表す形式。  
この形式における「年」は100で割ったときの商なので%/%100で求まる。  
「月」は100で割ったときの余りなので%%100で求まる。  

- - -

# 繰り返し

## for+rbindでくっつける  

※ただしめちゃ遅い→一度空のDFを作って値を入れていくと速くなる。  

### for文で変数名を変えながら代入

- [これ](https://ja.stackoverflow.com/questions/60048/r%e8%a8%80%e8%aa%9e-for%e6%96%87%e3%81%a7%e3%81%ae%e5%a4%89%e6%95%b0%e5%90%8d%e3%81%ae%e5%a4%89%e6%9b%b4%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6)

- - -

# 統計解析

## オッズ比算出

Epiパッケージ使う  
オッズ比の算出方法は通常の定義(unconditional MLE)、信頼区間はWaldの方法  

```{r}
a <- matrix()
twoby(a)
```

## カイ二乗検定

デフォルトの関数でもいいが、{infer}のchisq_test()が便利。  
tidy dataから検定用のテーブルを作らなくても、一発で検定できる。  

```{r}
library(infer)
mtcars %>%
  dplyr::mutate(cyl = factor(cyl), am = factor(am)) %>%
  chisq_test(cyl ~ am)
```


## t検定

## Wilcoxonの順位和検定

{coin}のwilcox_test()を使おう。  
[参考文献](https://blog.goo.ne.jp/r-de-r/e/019d0afc8e702b044768dd8eeaed3dcf)

```{r}
wilcox_test(number ~ group, data = df, distribution = "exact")
```

## ロジスティック回帰

### オッズ比と95%信頼区間を算出

デフォルトの関数summary()はそのままだと対数オッズ比を算出したり、95%CIを表示してくれなかったりする。 

#### broom

```{r}
library(broom)
tidy(model, conf.int = TRUE, exponentiate = TRUE)
```
#### epiDisplay

※epiDisplayはMASSという依存パッケージがあり、MASSの中にはselectという関数が入っている。dplyrのselectと競合するので注意！

```{r}
model <- glm(event ~ group + sex + age, family = binomial, data = df1)
summary(model)  # デフォルトだとよくわからない表示になる
library(epiDisplay)
logistic.display(model)  # odds ratioと95%CI
logistic.display(model, simplified = TRUE)  # 調整済odds ratio のみ表示
```

[参考文献](https://researchmap.jp/jomk5xr2p-1781589/)

### 多重共線性(マルチコ)

変数間の相関(?)が高いと推定が不安定になり、その状態のことを多重共線性が高いという。  
多重共線性の指標はVIFを用い、10以上だと多重共線性が高いとされる。  
多重共線性のチェックは以下のようにする。  

```{r}
library(car)
#重回帰分析の結果をresultに保存
result <- lm(a ~ x + y + z)
#重回帰分析の変数のVIF統計量を算出
vif(result)
```

[参考文献](https://qiita.com/DaichiHasegawa/items/d73da347b9ac81254c82)

## Cox回帰

{survival}と{survminer}を使う。

```{r}
library(survival)
library(survminer)
cox <- coxph(Surv(time, event) ~ group + sex + age, method = "breslow", data = dat)
ggforest(cox)
```

## 感度・特異度・PPV・NPV算出

### 関数あったので一応はっておきます  

- 適中率/Accuracy（全体の内，真陽性と真陰性が占める割合)  
- エラー率/Error Rate（1-適中率）  
- 感度/Sensitivity （真の状態が陽性であるもののうち，陽性と判断できた割合）  
- 特異度/Specificity （真の状態が陰性であるもののうち，陰性と判断できた割合）  
- 陽性適中率/PPV　（陽性と判断したもののうち，真の状態が陽性である割合）  
- 陰性適中率/NPV　（陰性と判断したもののうち，真の状態が陰性である割合）  
- 陽性尤度比　（真の状態が陽性であるひとが陰性であるひとよりも何倍検査結果が陽性になるか）  
- 陰性尤度比　（真の状態が陰性であるひとが陽性であるひとよりも何倍検査結果が陰性になるか）  

```{r}
my.indices <- function(CM){
	Rat <- CM/sum(CM)
	TP <- CM[1,1]
	TPr <- Rate[1,1]
	FP <- CM[1,2]
	FPr <- Rate[1,2]
	FN <- CM[2,1]
	FNr <- Rate[1,1]
	TN <- CM[2,2]
	TNr <- Rate[2,2]
	Acc <- (TP + TN) / sum(CM)
	Err <- 1 - Acc
	Sens <- TP / (TP + FN)
	Spec <- TN / (FP + TN)
	PPV <- TP / (TP + FP)
	NPV <- TN / (FN + TN)
	LRP <- Sens / (1 - Spec)
	LRN <- (1 - Sens) / Spec
	
	Result <- list(
		"Confusion Matrix" = CM,
		"Confusion Rates" = Rate,
		"Accuracy" = Acc,
		"Error Rate" = Err,
		"Sensitivity" = Sens,
		"Sepcificity" = Spec,
		"PPV" = PPV,
		"NPV" = NPV,
		"LR+" = LRP,
		"LR-" = LRN
		)	
	print(Result,digits = 3)
}
```
  
### {epiR}パッケージ

```{r}
library(epiR)
tabl <- matrix(c(32, 5, 6, 35), nrow = 2, byrow = TRUE)
epi.tests(tabl)
```

## 欠損データ解析

### 単一代入法

ダメ、絶対。

### 多重代入法

{mice}  
{Amelia}

- - -

# 表を作る

## {kable}

## {DT}

## {tableOne}

- - -

# 視覚化

## plot  

### hist  

例えば何人かの身長が入力されたdfがあるとする。  
hist()で描ける。

```{r}
hist(df$height)
```

以下のようにすると各度数の人数等、ヒストグラムの情報を含んだリストが得られる。

```{r}
abc <- hist(df$height)
```

その他、ラベルや軸の範囲など設定が可能。[参考文献1](https://data-science.gr.jp/implementation/ida_r_histogram.html)[参考文献2](https://stats.biopapyrus.jp/r/graph/hist.html)  
色も付けられる[色見本](http://www.okadajp.org/RWiki/?%E8%89%B2%E8%A6%8B%E6%9C%AC)

## ggplot2

ggplotはモダンな描画パッケージ。使わない手はない。

### 基本(未編集)

#### 図中にテキストラベルを入れる

- ggrepel(https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html)

### GUI

- https://note.com/tqwst408/n/n82d56c69a18e

### ggforest

## Kaplan-Meier曲線  

## 図の出力  

### 保存機能を使う  

RStudioのグラフデバイスのメニュー内「export」のタブをクリック。  
「Save as image」で、クリックして所定の設定をしたら、保存完了。  

### 関数を使う  

PNG画像、JPEG画像、PDF形式などで出力が可能。  
基本は同じ。例としてpng()を用いて説明する。JPEG画像はjpeg(),PDF形式はpdf()

```{r}
png("file name")
plot() #ここで図を描く関数を入れる。hist()等も可
dev.off() #fileへの描きこみ終了
```

大きさや解像度の設定も可能らしい。  
PDF形式だと1つのファイルにいくつも図がplotでき、まとめて保存できる。  
いい参考文献があれば教えてください。

### 1つの画像に複数描画(未編集)

```{r}
par(mfrow = c(2,2))
```

```{r}
facet
```

## 便利なサイト
- [data to viz](https://www.data-to-viz.com/)
  - 手持ちのデータから、どのように視覚化するかを教えてくれる


- - -

# 自作関数(関数定義)

3回同じ処理をするなら関数を作ろう。  
あとデータに依存する部分とプログラムを分離させる方がデバッグが簡単。  

- - -

# コメントアウト

## \# シャープ

Rスクリプトにコメントを残すには#をつける。

```{r}
manipulation(df, option = TRUE) # これはコメントです
```

コメントを残すのは、コードレビューしてもらうときのためと、自分が後で見返したときのため。  
最初は苦痛かもしれないが、トータルで絶対得なのでコメント書きまくろう。

## if(0){}

1行とかの操作を一時的に実行させない場合は上記の#を使えばいい。  
実行させたくない操作が多くの行にまたがっている場合は、if(0){}を使うのがおすすめ。

```{r}
if(0){
  veryverylong_action(df) %>% 
    hogehoge(piyo = TRUE) %>% 
    tonikaku_nagai_syori() %>% 
    hahaha()
  }
```

if(0){}で囲まれたコードは実行されない。実行させたいときはif(1){}とすればよいので、いわばスイッチになる。

- - -

# システム系

## 外部スクリプト実行

```{r}
source
```

## ファイル操作

- dir.create
- file.path
- file.remove
- file.rename
- file.append
- file.copy

## 時間計測

```{r}
system.time()
# ()の中に処理を書く
```

- - -

# パッケージ

## インストール

うまくいかないときは、素のRからやってみるといいこともある。

### パッケージ無かったらインストール

```{r}
if (!require("dplyr")) {install.packages("dplyr")}
```

### githubからインストール

CRAN等のレポジトリに登録されていないものはgithubからインストールする。devtoolsよりremotesを使う方がいいらしい。

```{r}
remotes::install_github("MikeKSmith/rspeaksnonmem")
```

## 読込

### requireとlibraryの違い

- require:パッケージが存在しない場合警告が出るが止まらない
- library:存在しない場合エラーで止まる

### 警告を出力せず読み込む

```{r}
suppressWarnings(library(tidyverse))
```

### 1行でまとめて読込

{pacman}パッケージを使うと便利。指定したパッケージがインストールされてなければ自動でダウンロードまでしてくれる。今後はこれを使っていくことが標準になっていく。

```{r}
pacman::p_load(dplyr, tidyr, dbplyr, magrittr, ggplot2)
```

### 現在読み込んでいるパッケージを確認

search()

## 便利なパッケージ

汎用性が高く、みんなにおすすめなものを列挙する。

### データ処理

- tidyverse  
基本中の基本。dplyr, lubridate, ggplot2などが入っている包括的なパッケージ。  
- openxlsx  
エクセル(.xlsx)を読み込む  

### 疫学研究で使う

- tableOne  
臨床研究、疫学論文のいわゆるtable1を作ってくれる。  
- survival,survminer  
生存時間分析するなら。
- Epi
- epiR

## パッケージの情報を得る

まずは「パッケージ名+R」で検索し、CRANの公式ドキュメントを見る。英語だがこれを見るのは大事。  
githubというサイトにはパッケージの関数がどのように定義されているかが載っているので余力があれば見る。  
  
以下のサイトを使えばGoogle翻訳を駆使して日本語で理解できるかも。

- [RDocumentation](https://www.rdocumentation.org/)
- [rdrr.io](https://rdrr.io/)
- [METACRAN](https://www.r-pkg.org/)

- - -

# R Markdown

## Markdownの基本

R Markdownは、Markdownの記法を知らないと使いこなせない。  
基本的な文法を以下に記すが、[Markdown記法](https://www.asobou.co.jp/blog/bussiness/markdown)を見たりググったりする方がわかりやすい。

<!-- table -->
|できること|書き方|
|---|---|
|見出し|「#」が1つで大見出し、2つで中見出し…|
|改行|半角スペース2つ|
|箇条書き|ハイフンと半角スペース|
|番号付き箇条書き|1と半角スペース|
|水平線|「-」をスペース挟んで3つ並べる|
|リンク|``[文字列](URL)``|
|画像|``![文字列](画像URL)``|

## R Markdownの基本

[クックブック](https://bookdown.org/yihui/rmarkdown-cookb)ook/

## Chunk Option

各Chunkごとに各種設定が行える  
[参考文献1](https://teramonagi.hatenablog.com/entry/20130615/1371303616) 
[参考文献2](http://gihyo.jp/admin/serial/01/r-markdown)  

マイナーだが便利なオプション  

- cache
- fig.width
- fig.height

### Global Option

Rmdファイル全体に適用したいoptionは、Global Optionとして設定できる。

```{r}
opts_chunk$set(prompt = TRUE, message = FALSE)
```

### Rmdでのディレクトリ設定

Rmdではsetwdをしてもチャンク毎にリセットされる。  
ファイルでディレクトリを設定したい場合は、以下のように設定する。

```{r}
opts_chunk$set(root.dir = "/path/to/folder/")
```

## テンプレート

「New File」→「R Markdown」と選び、「From Template」からテンプレが選べる。

### パッケージ

おすすめは{rmdformats}パッケージの「HTML clean template」。  

## パイプ %>% (未編集)

[参考文献](https://www.medi-08-data-06.work/entry/paipe_r)
[色々なパイプ](https://qiita.com/five-dots/items/616c5f07d7a68ec70f62)

### 中間の変数をオブジェクトに格納する

こんな感じ。[参考文献](https://www.medi-08-data-06.work/entry/paipe_r)

```{r}
df2 <- df %>% 
select(1, 2, 3) %>% 
{. ->> totyu } %>%
filter(age >= 60)
```

### 右辺の結果を左辺に代入する

```{r}
df %<>% 
  mutate(newvar = log(oldvar))

df <- df %>% 
  mutate(newvar = log(oldvar))
```

この2つのコードは等価

- - -

# Tips

## ググるにあたって

わからないことがあったらググる習慣をつけよう。  
特に、英語で検索をかけると望みのものが見つかることが多い。  
以下に検索に便利なキーワードの書いておく。  

<!-- table -->
|知りたいこと|キーワード|
|---|---|
|エラーの理由|エラーメッセージコピペ|
|tidy dataから検定したい|○○(検定名) + tidy|

## コーディングスタイルガイド

[tidyverse style guide](https://style.tidyverse.org/)を遵守していきたい。  

- [Advanced R 第1版](http://adv-r.had.co.nz/Style.html)
- [Advanced R 第2版](https://adv-r.hadley.nz/index.html)

## プログラミング時の留意点

### 心がけること

- 加工前後のデータを比較して、ロジックに問題がないか確認
- エラーはあるものと思い、何回も確認
- 第三者が見ても分かるようにコメントをつける
- 第三者にコードレビューしてもらう
- 対象者のフローチャートを書く

### できれば行いたいこと

- 変数定義書を作成
- 第三者にプログラムを書いてもらい、結果が一致するか確認(Independent Programming)

### 変数に関して

- データフレーム、変数名は_でつなぐ 
- saveしすぎない

## ミスしがちなところ

### 汎用的なところ

- タイプミス、スペルミス
- numeric、character、factor

### 医療情報データベース特有

- 年月の差をとるのに普通に引き算する
- 疑いフラグ抜き忘れる
- 処方日、検査値等の欠損をそのままにする

## RStudio Cloud

[RStudio Cloud](https://rstudio.cloud/)  
  
もはやPCにR Studioをインストールしなくても使える時代になりました。  
会員登録して以下を参考にやってみよう！  
※気軽に使えるので新入生ゼミ等に使えるかも

- [参考文献1](https://qiita.com/purple_jp/items/943ea284c9ce7213a211)
- [参考文献2](https://qiita.com/petadimensionlab/items/ea164445e455d2c52b66)

## Microsoft R Open

- https://mran.microsoft.com/open

## アップデート

アップデートは定期的に行いましょう！  
卒研発表とかで古いバージョンが書かれていたらチョット恥ずかしいよね。

### Rのアップデート

素のRから以下のコードを実行する。  
うまくいかない場合は普通に[ここ](https://cran.r-project.org/)からダウンロード。

```{r installr}
installr::updateR(browse_news = FALSE, install_R = TRUE, copy_packages = FALSE,copy_Rprofile.site = FALSE, keep_old_packages = FALSE, update_packages = TRUE, start_new_R = FALSE,quit_R = TRUE)
# 色々設定できるので興味あれば{installr}のマニュアル見て。
```

これをknitしたRのVersionは…
```{r echo = FALSE, eval = TRUE}
version[["version.string"]]
```


### R Studioのアップデート

「Help→Check for Updates」を押すと[ここ](https://rstudio.com/products/rstudio/download/)に飛ぶのでダウンロード。  

## ショートカットキー

<!-- table -->
|動作|キー|
|---|---|
|<-|Alt + -  |
|%>%|Ctrl+Shift+M|
|Rmarkdown knit|Ctrl+Shift+K|
|chunk挿入，chunk分割|Ctrl+Shift+I|
|インデント自動揃え|Ctrl+I|
|Consoleの+を消す|Esc|
|カーソルをスクリプトへ|Ctrl+1|
|カーソルをコンソールへ|Ctrl+2|
|関数自動作成|Ctrl+Alt+X|
|見出し,チャンクへジャンプ|Alt+Shift+J|
  
[参考文献](http://kohske.github.io/R/rstudio/cheetsheet/RStudio-Rmdv2-cheat.pdf)

## encoding

### 統一事項

UTF-8で統一する。新入生が入ったら一番最初にやらせること！

### 文字化けしたときは

「File」→「Reopen with Encoding…」からCP932かUTF-8を試すとうまくいくことが多い。  
CP932はWindows、UTF-8はMacやLinuxで使われることが多い。  
R MarkdownではUTF-8にしないと警告が出るが、別にCP932でもできる。  
  
## 属性ラベル

あまり知られていないが、列名とは別に属性ラベルをつけることができる。第三者に見せるとき、列を説明するのに便利。

```{r}
attr(data$name, "label") <- "名前"
```

## メモリ開放
[参考文献](http://knknkn.hatenablog.com/entry/2019/05/26/011705)

重いデータを読み込んだ時等に、Rの挙動が不安定になったときは以下を実行する。

```{r}
gc(reset = TRUE)
gc(reset = TRUE)
# なんか2回やるといいらしい
```

- - -

# 各種設定

[ここ](https://www.trifields.jp/various-settings-for-global-options-of-rstudio-2411)を参考に。  
割といじるところは多い。  

- - -

# サンプルデータ作成

## data.frame()を使う

```{r}
df <- data.frame(id = c(1,1,2,2,3,3,4,4), value = c("a","b","c","a","b","c","a","b"))
```

## read.table()を使う

```{r}
df <- read.table(text = "id  samediff  factor  value
1 S give    3
1 S impact  4
2 S give    2
2 S impact  5   
3 D give    1
3 D impact  4
4 D give    3
4 D impact  5", header = TRUE, stringsAsFactors = FALSE)
```

- - -

# 研究のやり方

## 研究デザインをドキュメントに起こす

研究デザイン、フローを示すことは非常に大切。

## スクリプトの基本的な流れ

1. setwd()
1. library()
1. source() 自作関数、他ファイル読込
1. load() データ読込
1. データハンドリング
1. 統計解析、table作成、視覚化

### データハンドリング(未編集)

疫学や臨床研究では、色々な除外条件で患者を絞っていくことがメインになる。

## のぞき見文化

基本的に研究プロジェクト1つにつき1フォルダを作成し、共有フォルダに置く。  
他の人の研究をのぞき見し、自分のプログラムに役立ちそうなことを盗みましょう。  
逆にその人へのアドバイスも積極的にしましょう。  

- - -

# R学習・コミュニティ

## coursera

コーセラは有名大学の講師によるオンライン講座。  
Rに関する講座もある。ただし英語が多い。日本語字幕があるのもある。

**まあまあおすすめ**

- Reproducible Research ジョンズ・ホプキンズ大学(Johns Hopkins University)  
R Studioの設定とかを言ってた。実は最初の方に見ておくといいかもしれない。  
  
**かなりムズイ**

- R Programming ジョンズ・ホプキンズ大学(Johns Hopkins University)  
  - データの型とかそういうことを説明してた。
- Getting and Cleaning Data ジョンズ・ホプキンズ大学(Johns Hopkins University)

  
## swirl

swirlはRでRの操作について勉強ができるパッケージ。  

## 使い方

swirlパッケージを読み込み→swirl()で始める。  
bye,skip,play,nxt,main,delete_progress,uninstall_all_courses

### コース

[ここ](http://swirlstats.com/scn/title.html)で好きなコースを選ぶ。  
  
**おすすめのコース(上の方からやるのがいいと思う)**  

- A (Very) Short Introduction to R  
- R programming  
- Getting and Cleaning Data  
- Exploratory Data Analysis  
- Advanced R Programming  
- Regular Expressions(テキスト処理)  
  
## Rの情報を得る

### ネット

- [R初心者の館](https://das-kino.hatenablog.com/entry/2019/11/07/1250449)
- [Rによるデータ前処理実習](https://heavywatal.github.io/slides/tmd2019/)
- [R関連の情報源](https://qiita.com/maruman029/items/4963d483c6cd0fb50770)
- [Rクックブック](https://rc2e.com/)

### 勉強会・セミナー・講習

- R勉強会(Tokyo.R)
  - おおよそ月1回。学生は無料。優秀な人たちが多く刺激を受ける。  

### 書籍

- RユーザのためのRStudio［実践］入門
  - 通称「宇宙本」。tidyverseによるモダンな分析フローの世界が書いてある。おすすめ。

- 医療統計のやつ  
  - 岡田さんのやつ。おすすめ。  

- - -

# 雑多なメモ(今後上に追加していく)

- attach
- gather,spread pivot_longer,pivot_wider
- group_nest
- n()
- 共変量取得関数
- [https://www.marketechlabo.com/r-tips/](https://www.marketechlabo.com/r-tips/)
